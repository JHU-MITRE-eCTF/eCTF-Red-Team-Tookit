from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import struct
def add_padding(data: bytes) -> bytes:
    """Add padding to the data to make its length a multiple of 16 bytes."""
    padding_length = 16 - (len(data) % 16)
    return data + (b'\x00' * padding_length)

def encrypt_data(key: bytes, data: bytes) -> bytes:
    """Encrypt data using AES-128 in ECB mode."""
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
    encryptor = cipher.encryptor()
    return encryptor.update(data) + encryptor.finalize()

def gen_subscription(secrets: bytes, device_id: int, start: int, end: int, channel: int) -> bytes:
    """Generate the contents of a subscription.

    The output of this will be passed to the Decoder using ectf25.tv.subscribe

    :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
    :param device_id: Device ID of the Decoder
    :param start: First timestamp the subscription is valid for
    :param end: Last timestamp the subscription is valid for
    :param channel: Channel to enable
    """
    key = b'\xb8\xdc\xdaA\xef\xb6i\xa3d\x1a\xc9\x8b\xf8\x9f\x87\x1d'
    print(f"device_id: {device_id:02x}, start:{start:02x}, end:{end:02x}, channel:{channel:02x}")
    packet = struct.pack("<IQQI", device_id, start, end, channel)
    print(f"{packet.hex()}")
    packet = add_padding(packet)
    return encrypt_data(key, packet)

def print_split_hex16(hex_string):
    # Ensure the input is a hex string (remove '0x' if present)
    hex_string = hex_string.lstrip("0x")

    # Split into 16-byte (32 hex character) chunks
    chunk_size = 32  # 16 bytes = 32 hex characters
    chunks = [hex_string[i:i + chunk_size] for i in range(0, len(hex_string), chunk_size)]

    # Print with black block separator
    print(" â–ˆ ".join(chunks))
    
def fake_pirated_sub(own_sub, pirated_sub, faked_sub) -> bytes:
    with open(own_sub, 'rb') as f:
        decoder_id_truncation = f.read()[:16]
    with open(pirated_sub, 'rb') as f:
        channel_id_truncation = f.read()[16:]
    fake_sub = decoder_id_truncation + channel_id_truncation
    with open(faked_sub, 'wb') as f:
        f.write(fake_sub)

# print_split_hex16(gen_subscription(0, 0xb804d98f, 1891690566834715, 0x6b87b8843d920, 1).hex())
# print_split_hex16(gen_subscription(0, 0xb804d98f, 1891690566834715, 0x112238843d920, 1).hex())
fake_pirated_sub('/Users/jiachengzhong/project/jhu-research/ectf/attack-phase/binghamton_package/own.sub'\
    , '/Users/jiachengzhong/project/jhu-research/ectf/attack-phase/binghamton_package/pirated.sub',\
    '/Users/jiachengzhong/project/jhu-research/ectf/attack-phase/binghamton_package/faked.sub')